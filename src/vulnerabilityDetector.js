class VulnerabilityDetector {
  constructor() {
    this.vulnerabilities = [];
  }

  analyze(contractCode, filename) {
    this.vulnerabilities = [];
    this.filename = filename;
    
    this.checkReentrancy(contractCode);
    this.checkAccessControl(contractCode);
    this.checkIntegerOverflow(contractCode);
    this.checkGasLimits(contractCode);
    
    return {
      filename: this.filename,
      vulnerabilities: this.vulnerabilities,
      riskLevel: this.calculateRiskLevel()
    };
  }

  checkReentrancy(code) {
    const lines = code.split('\n');
    const externalCallPattern = /\.(call|send|transfer)\s*\(/;
    const stateChangePattern = /(balance\s*=|balances\[.*\]\s*=|\w+\s*=)/;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      
      if (externalCallPattern.test(line)) {
        for (let j = i + 1; j < Math.min(i + 10, lines.length); j++) {
          if (stateChangePattern.test(lines[j])) {
            this.vulnerabilities.push({
              type: 'REENTRANCY_RISK',
              severity: 'HIGH',
              line: i + 1,
              description: 'External call followed by state change - potential reentrancy vulnerability',
              recommendation: 'Use checks-effects-interactions pattern or reentrancy guard'
            });
            break;
          }
        }
      }
    }
  }

  checkAccessControl(code) {
    const lines = code.split('\n');
    const publicFunctionPattern = /function\s+\w+\s*\([^)]*\)\s+public/;
    const modifierPattern = /\bonlyOwner\b|\brequire\s*\(\s*msg\.sender/;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      
      if (publicFunctionPattern.test(line) && !modifierPattern.test(line)) {
        if (line.includes('withdraw') || line.includes('transfer') || line.includes('mint')) {
          this.vulnerabilities.push({
            type: 'ACCESS_CONTROL',
            severity: 'MEDIUM',
            line: i + 1,
            description: 'Public function without access control detected',
            recommendation: 'Add appropriate access control modifiers'
          });
        }
      }
    }
  }

  checkIntegerOverflow(code) {
    const lines = code.split('\n');
    const arithmeticPattern = /(\+\+|--|\+=|-=|\*=|\/=)/;
    const safeKeyword = /(SafeMath|checked)/;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      
      if (arithmeticPattern.test(line) && !safeKeyword.test(line)) {
        this.vulnerabilities.push({
          type: 'INTEGER_OVERFLOW',
          severity: 'LOW',
          line: i + 1,
          description: 'Potential integer overflow in arithmetic operation',
          recommendation: 'Consider using SafeMath library or Solidity 0.8+ built-in overflow checks'
        });
      }
    }
  }

  checkGasLimits(code) {
    const lines = code.split('\n');
    const loopPattern = /\b(for|while)\s*\(/;
    const arrayIterationPattern = /\[\s*\w+\s*\]/;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      
      if (loopPattern.test(line)) {
        for (let j = i; j < Math.min(i + 20, lines.length); j++) {
          if (arrayIterationPattern.test(lines[j]) || lines[j].includes('.push(') || lines[j].includes('.length')) {
            this.vulnerabilities.push({
              type: 'GAS_LIMIT',
              severity: 'MEDIUM',
              line: i + 1,
              description: 'Loop with dynamic array operations - potential gas limit issue',
              recommendation: 'Consider pagination or limiting array size to prevent gas limit errors'
            });
            break;
          }
        }
      }

      if (line.includes('.call{gas:') && !line.includes('gasleft()')) {
        this.vulnerabilities.push({
          type: 'GAS_STIPEND',
          severity: 'LOW',
          line: i + 1,
          description: 'Fixed gas stipend may cause issues with contract upgrades',
          recommendation: 'Consider using gasleft() or allowing gas parameter adjustment'
        });
      }
    }
  }

  calculateRiskLevel() {
    const highCount = this.vulnerabilities.filter(v => v.severity === 'HIGH').length;
    const mediumCount = this.vulnerabilities.filter(v => v.severity === 'MEDIUM').length;
    
    if (highCount > 0) return 'HIGH';
    if (mediumCount > 0) return 'MEDIUM';
    return 'LOW';
  }
}

module.exports = VulnerabilityDetector;